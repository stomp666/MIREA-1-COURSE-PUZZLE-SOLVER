// у вас матрица M x M
   /*
   *
   * Чёрно-белый пазл
   *
   Шаг 1

   Каждый элемент матрицы это структура
   4 целочисленных числа и булева
   Целочисленные - тип выступа, вводится число k, целочисленное по модулю <= k
   Выступы не уникальны, выступы с краёв без ответных частей случайным образом (не 0)
   Булева - какой-то рисунок

   Шаг 2

   перемешка пазла в случайном порядке

   Шаг 3

   Собрать пазл ориентируясь на выступы элементов и зная оригинальную картинку
   Если сможете: в реальном времени выводить процесс решения

   Ньюанс

   При неверной постановке решения пазла откатить назад
   */

#include <iostream>
#include <string>
#include <algorithm>
#include <Windows.h>
#include <stdlib.h>
#include <time.h>
#include <conio.h>
#include <vector>

#define r_key 114
#define R_KEY 82
#define g_key 103
#define G_KEY 71
#define s_key 115
#define S_KEY 83
#define p_key 112
#define P_KEY 80
#define exit_key 48
#define debug_key 49

using namespace std;

HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);

struct piece {
    int up, right, down, left;
    bool pixel;
};

bool** image;
piece** image_sliced;
int MaxPossibleValue = 5;
int puzzleSize = 1;
bool IsGenerated = false;

string ArraySolversBuf;
vector<string> arrayTL;
vector<string> arrayTR;
vector<string> arrayDL;
vector<string> arrayDR;
// мне плевать буду вектора использовать
void generate()
{
    system("CLS");
    /* как выглядит матрица
    * допустим она = 2х2
    *  выглядит так:
    *
    *       -4         7
    *      3 T 16  -16 F 29
    *        5         4
    *
    *       -5        -4
    *      8 F 2    -2 T 13
    *        3         67
    *
    */
    // Также: числа = целочисленные и <= k. чем меньше k тем хуже. а вводит его ПОЛЬЗОВАТЕЛЬ
    // T/F = bool

    IsGenerated = true;
    printf("Enter puzzle size.\n");
    cin >> puzzleSize;
    system("CLS");
    if (puzzleSize < 2)
    {
        cout << "Can't generate.\n";
        exit(0);
    }

    printf("Please enter a number to make a puzzle sort difficulty.\n\nHard        Easy\n1            INF\n<-------------->\n");
    cin >> MaxPossibleValue;

    if (cin.fail())
    {
        cout << "Bad Value\n";
        return;
    }

    image = new bool* [puzzleSize];
    image_sliced = new piece* [puzzleSize];

    for (int i = 0; i < puzzleSize; i++)
    {
        image_sliced[i] = new piece[puzzleSize];
    }
    arrayTL.resize(puzzleSize);
    arrayTR.resize(puzzleSize);
    arrayDL.resize(puzzleSize);
    arrayDR.resize(puzzleSize);
    for (int i = 0; i < puzzleSize; i++)
    {
        image[i] = new bool[puzzleSize];

        for (int j = 0; j < puzzleSize; j++)
        {
            image[i][j] = rand() % 2;
            if (image_sliced[i][j].up >= 0 || image_sliced[i][j].up == -842150451) {
                image_sliced[i][j].up = (rand() % MaxPossibleValue) + 1;
            }

            image_sliced[i][j].right = (rand() % MaxPossibleValue) + 1;
            if (image_sliced[i][j].left >= 0 || image_sliced[i][j].left == -842150451)
            {
                image_sliced[i][j].left = (rand() % MaxPossibleValue) + 1;
            }
            image_sliced[i][j].down = (rand() % MaxPossibleValue) + 1;
            image_sliced[i][j].pixel = image[i][j];
            
            if (i < puzzleSize - 1) {
                image_sliced[i + 1][j].up = -image_sliced[i][j].down;
            }
            if (j < puzzleSize - 1)
            {
                image_sliced[i][j + 1].left = -image_sliced[i][j].right;
            }
            
            ArraySolversBuf += to_string(image_sliced[i][j].up);
            ArraySolversBuf += ",";
            ArraySolversBuf += to_string(image_sliced[i][j].left);
            arrayTL[i] = ArraySolversBuf;
            ArraySolversBuf = "";
            ArraySolversBuf += to_string(image_sliced[i][j].up);
            ArraySolversBuf += ",";
            ArraySolversBuf += to_string(image_sliced[i][j].right);
            arrayTR[i] = ArraySolversBuf;
            ArraySolversBuf = "";
            ArraySolversBuf += to_string(image_sliced[i][j].left);
            ArraySolversBuf += ",";
            ArraySolversBuf += to_string(image_sliced[i][j].down);
            arrayDL[i] = ArraySolversBuf;
            ArraySolversBuf = "";
            ArraySolversBuf += to_string(image_sliced[i][j].right);
            ArraySolversBuf += ",";
            ArraySolversBuf += to_string(image_sliced[i][j].down);
            arrayDR[i] = ArraySolversBuf;
            ArraySolversBuf = "";
        }
    }
    system("CLS");
    FixBadCorners();
}
void FixBadCorners()
{
    for (int i = 0; i < puzzleSize; i++)
    {
        for (int j = 0; j < puzzleSize; j++)
        {
            if (arrayTL[i] == arrayTL[j] && i != j)
            {
                if (image_sliced[i][j].up > 0)
                {
                    image_sliced[i][j].up += 100;
                }
                if (image_sliced[i][j].left > 0)
                {
                    image_sliced[i][j].left += 100;
                }
            }
            if (arrayTR[i] == arrayTR[j] && i != j)
            {
                image_sliced[i][j].right += 100;
            }
            if (arrayDL[i] == arrayDL[j] && i != j)
            {
                image_sliced[i][j].down += 100;
            }
            if (arrayDR[i] == arrayDR[j] && i != j)
            {
                image_sliced[i][j].down += 100;
            }
        }
    }
}
void randomize()
{
    system("CLS");
    if (IsGenerated == false)
    {
        cout << "Image is not generated.\n\n";
        return;
    }
    time_t currentTime{};
    time(&currentTime);
    struct tm* myTime = localtime(&currentTime);

    piece buffer;
    for (int i = 0; i < puzzleSize; i++)
    {
        for (int j = 0; j < puzzleSize; j++)
        {
            int randomNumber = rand() % 100 + puzzleSize;
            int x = ((myTime->tm_sec) + randomNumber) % puzzleSize;
            int y = ((myTime->tm_sec) + randomNumber + 16) % puzzleSize;
            buffer = image_sliced[i][j];
            image_sliced[i][j] = image_sliced[x][y];
            image_sliced[x][y] = buffer;
        }
    }
    for (int i = 0; i < puzzleSize; i++)
    {
        for (int j = 0; j < puzzleSize; j++)
        {
            // cout << (image_sliced[i][j].pixel ? 1 : 0) << " ";
        }
        //cout << endl;
    }
    // cout << endl;
    system("CLS");
}
void solve()
{
    system("CLS");
    piece buffer;
    if (IsGenerated == false)
    {
        system("CLS");
        cout << "Image is not generated.\n\n";
        return;
    }
    int check = 0;
    for (int i = 0; i < puzzleSize; i++) // упростить работу, т.к. первый пазл всегда имеет числа >0
    {
        for (int j = 0; j < puzzleSize; j++)
        {
            if (image_sliced[i][j].up > 0 && image_sliced[i][j].down > 0 && image_sliced[i][j].left > 0 && image_sliced[i][j].right > 0)
            {
                buffer = image_sliced[0][0];
                image_sliced[0][0] = image_sliced[i][j];
                image_sliced[i][j] = buffer;
            }
        }
    }
    
    for (int i = 0; i < puzzleSize; i++)
    {
        for (int j = 0; j < puzzleSize; j++)
        {
            for (int z = 0; z < puzzleSize; z++)
            {
                for (int a = 0; a < puzzleSize; a++)
                {
                    if (a == j && z == i)
                    {
                        continue;
                    }
                    if (i + 1 == puzzleSize)
                    {
                        continue;
                    }
                    if (image_sliced[i][j].down != -(image_sliced[i + 1][j].up) && image_sliced[i][j].down == -(image_sliced[z][a].up))
                    {
                        if (image_sliced[i][j].pixel == image[i][j])
                        {
                            buffer = image_sliced[i + 1][j];
                            image_sliced[i + 1][j] = image_sliced[z][a];
                            image_sliced[z][a] = buffer;
                        }
                    }
                    if (j + 1 == puzzleSize)
                    {
                        continue;
                    }
                    if (image_sliced[i][j].right == -(image_sliced[z][a].left) && image_sliced[i][j].right != -(image_sliced[i][j + 1].left))
                    {
                        if (image_sliced[i][j].pixel == image[i][j])
                        {
                            buffer = image_sliced[i][j + 1];
                            image_sliced[i][j + 1] = image_sliced[z][a];
                            image_sliced[z][a] = buffer;
                        }
                    }
                }
            }

            cout << (image_sliced[i][j].pixel ? SetConsoleTextAttribute(hConsole, 15), (char)254u : SetConsoleTextAttribute(hConsole, 8), (char)254u) << " ";
        }
        cout << endl;
    }
    Sleep(5);
    system("CLS");
    for (int i = 0; i < puzzleSize; i++)
    {
        for (int j = 0; j < puzzleSize; j++)
        {
            cout << (image_sliced[i][j].pixel ? SetConsoleTextAttribute(hConsole, 15), (char)254u : SetConsoleTextAttribute(hConsole, 8), (char)254u) << " ";
        }
        cout << endl;
    }
    cout << "\n\nSolved. Press enter to go to menu.\n";
    cin.get();
    system("CLS");
}

void printpuzzle()
{
    system("CLS");
    if (IsGenerated == false)
    {
        cout << "Image is not generated.\n\n";
        return;
    }
    cout << "Normal Image\n";
    for (int i = 0; i < puzzleSize; i++)
    {
        for (int j = 0; j < puzzleSize; j++)
        {
            cout << (image[i][j] ? SetConsoleTextAttribute(hConsole, 15), (char)254u : SetConsoleTextAttribute(hConsole, 8), (char)254u) << " ";
        }
        cout << endl;
    }
    cout << "Puzzle\n";
    for (int i = 0; i < puzzleSize; i++)
    {
        for (int j = 0; j < puzzleSize; j++)
        {
            cout << (image_sliced[i][j].pixel ? SetConsoleTextAttribute(hConsole, 15), (char)254u : SetConsoleTextAttribute(hConsole, 8), (char)254u) << " ";
        }
        cout << endl;
    }
    SetConsoleTextAttribute(hConsole, 15);
    printf("Press enter to go back to menu.\n");
    cin.get();
    system("CLS");
}

void void_debug()
{
    system("CLS");
    if (IsGenerated == false)
    {
        system("CLS");
        cout << "Image is not generated.\n\n";
        return;
    }
    /*cout << "     A" << endl;
    cout << "   B 0 C" << endl;
    cout << "     D" << endl;
    for (int i = 0; i < puzzleSize; i++)
    {
        cout << endl <<"             A,B";
        cout << "\nvector TL: " << arrayTL[i];
        cout << endl << "             A,C";
        cout << "\nvector TR: " << arrayTR[i];
        cout << endl << "             C,D";
        cout << "\nvector DR: " << arrayDR[i];
        cout << endl << "             B,D";
        cout << "\nvector DL: " << arrayDL[i];
        cout << endl;
    }*/
    cout << endl << endl << endl;
    for (int i = 0; i < puzzleSize; i++)
    {
        for (int j = 0; j < puzzleSize; j++)
        {
            if (arrayTL[i] == arrayTL[j] && i != j)
            {
                cout << "\nfound duplicate for TL\n";
                if (image_sliced[i][j].up > 0)
                {
                    image_sliced[i][j].up += 100;
                }
                if (image_sliced[i][j].left > 0)
                {
                    image_sliced[i][j].left += 100;
                }
            }
            if (arrayTR[i] == arrayTR[j] && i != j)
            {
                cout << "\nfound duplicate for TR\n";
                image_sliced[i][j].right += 100;
            }
            if (arrayDL[i] == arrayDL[j] && i != j)
            {
                cout << "\nfound duplicate for DL\n";
                image_sliced[i][j].down += 100;
            }
            if (arrayDR[i] == arrayDR[j] && i != j)
            {
                cout << "\nfound duplicate for DR\n";
                image_sliced[i][j].down += 100;
            }
        }
    }
    
}

int main()
{
    int c = 0;
    while (1)
    {

        SetConsoleTextAttribute(hConsole, 15);
        printf("Welcome to puzzle solver.\n\n");
        printf("Press 'g' to generate image.\nPress 'r' to transfer image into puzzle.\nPress 's' to solve.\nPress 'p' to print image.\nPress 0 to exit.\n\n");

        switch ((c = _getch()))
        {
        case exit_key:
            exit(0);
        case g_key:
        case G_KEY:
            generate();
            break;
        case r_key:
        case R_KEY:
            randomize();
            break;
        case s_key:
        case S_KEY:
            solve();
            break;
        case p_key:
        case P_KEY:
            printpuzzle();
            break;
        case debug_key:
            void_debug();
            break;
        default:
            system("CLS");
            break;
        }

    }
}
